### SORT CELLS
# (1) Setup initial cell count matrix with number of cells equal to the number of cells sorted
OGcounts <- data.frame("Cell_ID"= c(seq(1,library_size))) %>%                             # create matrix with cells equal to sorted library size
add_column(    gr = rnorm(nrow(.), mean=mean_growth_rate, sd=sd_growth_rate), # sample growth rates from normal distribution
counts = c(rep(1,library_size)) )                                  # set initial count of each subclone to 1
OGcounts <- OGcounts %>% mutate(abund= counts/sum(OGcounts$counts))                       # add new column for subclonal abundance
# (2) Stochastic selection of cells that die post-cell sort
cells_lost_sort = sample(    x = OGcounts$Cell_ID,                                        # choose from set of Cell_IDs in data frame
size = round(prob_cellsort_death*sum(OGcounts$counts)),         # select number of cells equal to current number of cells multiplied by probability of death post cell sort (prob_cellsort_death)
prob = OGcounts$abund )                                         # weight probability of Cell_ID selection by abundance
SortMatrix <- OGcounts[OGcounts$Cell_ID %not in% cells_lost_sort, ]                       # store selected cells in new data frame
# (3) Determine time to research ~50k cells from starting number of cells post-sort
SortMax_gr = max(SortMatrix$gr)                                                           # calculate max growth rate of selected cells
num_uniq = length(unique(SortMatrix$Cell_ID))
t_expand = solvet(g = SortMax_gr, N0 = sum(SortMatrix$counts), Nfinal = 45e3, k = 55e3)   # solve logistic growth equation for expansion time
# (4) Simulate growth of each subclone to t_expand and store new cell counts and abundance in data frame
SortOut <- SortMatrix %>% select(-abund) %>%
mutate(counts = floor(solveN(g = gr, N0 = counts, tf = t_expand, k = 55e3)),         #
abund = counts/sum(counts))
head(SortOut)
print(paste("total number of cells after expansion = ",sum(SortOut$counts)))
set.seed(1212)
### SORT CELLS
# (1) Setup initial cell count matrix with number of cells equal to the number of cells sorted
OGcounts <- data.frame("Cell_ID"= c(seq(1,library_size))) %>%                             # create matrix with cells equal to sorted library size
add_column(    gr = rnorm(nrow(.), mean=mean_growth_rate, sd=sd_growth_rate), # sample growth rates from normal distribution
counts = c(rep(1,library_size)) )                                  # set initial count of each subclone to 1
OGcounts <- OGcounts %>% mutate(abund= counts/sum(OGcounts$counts))                       # add new column for subclonal abundance
# (2) Stochastic selection of cells that die post-cell sort
cells_lost_sort = sample(    x = OGcounts$Cell_ID,                                        # choose from set of Cell_IDs in data frame
size = round(prob_cellsort_death*sum(OGcounts$counts)),         # select number of cells equal to current number of cells multiplied by probability of death post cell sort (prob_cellsort_death)
prob = OGcounts$abund )                                         # weight probability of Cell_ID selection by abundance
SortMatrix <- OGcounts[OGcounts$Cell_ID %not in% cells_lost_sort, ]                       # store selected cells in new data frame
# (3) Determine time to research ~50k cells from starting number of cells post-sort
SortMax_gr = max(SortMatrix$gr)                                                           # calculate max growth rate of selected cells
num_uniq = length(unique(SortMatrix$Cell_ID))
t_expand = solvet(g = SortMax_gr, N0 = sum(SortMatrix$counts), Nfinal = 40e3, k = 55e3)   # solve logistic growth equation for expansion time
# (4) Simulate growth of each subclone to t_expand and store new cell counts and abundance in data frame
SortOut <- SortMatrix %>% select(-abund) %>%
mutate(counts = floor(solveN(g = gr, N0 = counts, tf = t_expand, k = 55e3)),         #
abund = counts/sum(counts))
head(SortOut)
print(paste("total number of cells after expansion = ",sum(SortOut$counts)))
set.seed(1212)
### SORT CELLS
# (1) Setup initial cell count matrix with number of cells equal to the number of cells sorted
OGcounts <- data.frame("Cell_ID"= c(seq(1,library_size))) %>%                             # create matrix with cells equal to sorted library size
add_column(    gr = rnorm(nrow(.), mean=mean_growth_rate, sd=sd_growth_rate), # sample growth rates from normal distribution
counts = c(rep(1,library_size)) )                                  # set initial count of each subclone to 1
OGcounts <- OGcounts %>% mutate(abund= counts/sum(OGcounts$counts))                       # add new column for subclonal abundance
# (2) Stochastic selection of cells that die post-cell sort
cells_lost_sort = sample(    x = OGcounts$Cell_ID,                                        # choose from set of Cell_IDs in data frame
size = round(prob_cellsort_death*sum(OGcounts$counts)),         # select number of cells equal to current number of cells multiplied by probability of death post cell sort (prob_cellsort_death)
prob = OGcounts$abund )                                         # weight probability of Cell_ID selection by abundance
SortMatrix <- OGcounts[OGcounts$Cell_ID %not in% cells_lost_sort, ]                       # store selected cells in new data frame
# (3) Determine time to research ~50k cells from starting number of cells post-sort
SortMax_gr = max(SortMatrix$gr)                                                           # calculate max growth rate of selected cells
num_uniq = length(unique(SortMatrix$Cell_ID))
t_expand = solvet(g = SortMax_gr, N0 = sum(SortMatrix$counts), Nfinal = 50e3, k = 55e3)   # solve logistic growth equation for expansion time
# (4) Simulate growth of each subclone to t_expand and store new cell counts and abundance in data frame
SortOut <- SortMatrix %>% select(-abund) %>%
mutate(counts = floor(solveN(g = gr, N0 = counts, tf = t_expand, k = 55e3)),         #
abund = counts/sum(counts))
head(SortOut)
print(paste("total number of cells after expansion = ",sum(SortOut$counts)))
set.seed(1212)
### SORT CELLS
# (1) Setup initial cell count matrix with number of cells equal to the number of cells sorted
OGcounts <- data.frame("Cell_ID"= c(seq(1,library_size))) %>%                             # create matrix with cells equal to sorted library size
add_column(    gr = rnorm(nrow(.), mean=mean_growth_rate, sd=sd_growth_rate), # sample growth rates from normal distribution
counts = c(rep(1,library_size)) )                                  # set initial count of each subclone to 1
OGcounts <- OGcounts %>% mutate(abund= counts/sum(OGcounts$counts))                       # add new column for subclonal abundance
# (2) Stochastic selection of cells that die post-cell sort
cells_lost_sort = sample(    x = OGcounts$Cell_ID,                                        # choose from set of Cell_IDs in data frame
size = round(prob_cellsort_death*sum(OGcounts$counts)),         # select number of cells equal to current number of cells multiplied by probability of death post cell sort (prob_cellsort_death)
prob = OGcounts$abund )                                         # weight probability of Cell_ID selection by abundance
SortMatrix <- OGcounts[OGcounts$Cell_ID %not in% cells_lost_sort, ]                       # store selected cells in new data frame
# (3) Determine time to research ~50k cells from starting number of cells post-sort
SortMax_gr = max(SortMatrix$gr)                                                           # calculate max growth rate of selected cells
num_uniq = length(unique(SortMatrix$Cell_ID))
t_expand = solvet(g = SortMax_gr, N0 = sum(SortMatrix$counts), Nfinal = 55e3, k = 55e3)   # solve logistic growth equation for expansion time
# (4) Simulate growth of each subclone to t_expand and store new cell counts and abundance in data frame
SortOut <- SortMatrix %>% select(-abund) %>%
mutate(counts = floor(solveN(g = gr, N0 = counts, tf = t_expand, k = 55e3)),         #
abund = counts/sum(counts))
head(SortOut)
print(paste("total number of cells after expansion = ",sum(SortOut$counts)))
0.8*k_96well
sd_growth_rate = 0.003        # standard deviation around mean growth rate [1/hr]
prob_cellsort_death = 0.15    # probability of death after cell sort [ ]
k_96well = 55e3               # carrying capacity of a 96-well plate [number of cells]
0.8*k_96well
0.85*k_96well
set.seed(1212)
### SORT CELLS
# (1) Setup initial cell count matrix with number of cells equal to the number of cells sorted
OGcounts <- data.frame("Cell_ID"= c(seq(1,library_size))) %>%                             # create matrix with cells equal to sorted library size
add_column(    gr = rnorm(nrow(.), mean=mean_growth_rate, sd=sd_growth_rate), # sample growth rates from normal distribution
counts = c(rep(1,library_size)) )                                  # set initial count of each subclone to 1
OGcounts <- OGcounts %>% mutate(abund= counts/sum(OGcounts$counts))                       # add new column for subclonal abundance
# (2) Stochastic selection of cells that die post-cell sort
cells_lost_sort = sample(    x = OGcounts$Cell_ID,                                        # choose from set of Cell_IDs in data frame
size = round(prob_cellsort_death*sum(OGcounts$counts)),         # select number of cells equal to current number of cells multiplied by probability of death post cell sort (prob_cellsort_death)
prob = OGcounts$abund )                                         # weight probability of Cell_ID selection by abundance
SortMatrix <- OGcounts[OGcounts$Cell_ID %not in% cells_lost_sort, ]                       # store selected cells in new data frame
# (3) Determine time to research ~50k cells from starting number of cells post-sort
SortMax_gr = max(SortMatrix$gr)                                                           # calculate max growth rate of selected cells
num_uniq = length(unique(SortMatrix$Cell_ID))
t_expand = solvet(g = SortMax_gr, N0 = sum(SortMatrix$counts), Nfinal = 0.85*k_96well, k = k_96well)   # solve logistic growth equation for expansion time
# (4) Simulate growth of each subclone to t_expand and store new cell counts and abundance in data frame
SortOut <- SortMatrix %>% select(-abund) %>%
mutate(counts = floor(solveN(g = gr, N0 = counts, tf = t_expand, k = k_96well)),         #
abund = counts/sum(counts))
head(SortOut)
print(paste("total number of cells after expansion = ",sum(SortOut$counts)))
0.90*k_96well
set.seed(1212)
### SORT CELLS
# (1) Setup initial cell count matrix with number of cells equal to the number of cells sorted
OGcounts <- data.frame("Cell_ID"= c(seq(1,library_size))) %>%                             # create matrix with cells equal to sorted library size
add_column(    gr = rnorm(nrow(.), mean=mean_growth_rate, sd=sd_growth_rate), # sample growth rates from normal distribution
counts = c(rep(1,library_size)) )                                  # set initial count of each subclone to 1
OGcounts <- OGcounts %>% mutate(abund= counts/sum(OGcounts$counts))                       # add new column for subclonal abundance
# (2) Stochastic selection of cells that die post-cell sort
cells_lost_sort = sample(    x = OGcounts$Cell_ID,                                        # choose from set of Cell_IDs in data frame
size = round(prob_cellsort_death*sum(OGcounts$counts)),         # select number of cells equal to current number of cells multiplied by probability of death post cell sort (prob_cellsort_death)
prob = OGcounts$abund )                                         # weight probability of Cell_ID selection by abundance
SortMatrix <- OGcounts[OGcounts$Cell_ID %not in% cells_lost_sort, ]                       # store selected cells in new data frame
# (3) Determine time to research ~50k cells from starting number of cells post-sort
SortMax_gr = max(SortMatrix$gr)                                                           # calculate max growth rate of selected cells
num_uniq = length(unique(SortMatrix$Cell_ID))
t_expand = solvet(g = SortMax_gr, N0 = sum(SortMatrix$counts), Nfinal = 0.90*k_96well, k = k_96well)   # solve logistic growth equation for expansion time
# (4) Simulate growth of each subclone to t_expand and store new cell counts and abundance in data frame
SortOut <- SortMatrix %>% select(-abund) %>%
mutate(counts = floor(solveN(g = gr, N0 = counts, tf = t_expand, k = k_96well)),         #
abund = counts/sum(counts))
head(SortOut)
print(paste("total number of cells after expansion = ",sum(SortOut$counts)))
set.seed(1212)
### SORT CELLS
# (1) Setup initial cell count matrix with number of cells equal to the number of cells sorted
OGcounts <- data.frame("Cell_ID"= c(seq(1,library_size))) %>%                             # create matrix with cells equal to sorted library size
add_column(    gr = rnorm(nrow(.), mean=mean_growth_rate, sd=sd_growth_rate), # sample growth rates from normal distribution
counts = c(rep(1,library_size)) )                                  # set initial count of each subclone to 1
OGcounts <- OGcounts %>% mutate(abund= counts/sum(OGcounts$counts))                       # add new column for subclonal abundance
# (2) Stochastic selection of cells that die post-cell sort
cells_lost_sort = sample(    x = OGcounts$Cell_ID,                                        # choose from set of Cell_IDs in data frame
size = round(prob_cellsort_death*sum(OGcounts$counts)),         # select number of cells equal to current number of cells multiplied by probability of death post cell sort (prob_cellsort_death)
prob = OGcounts$abund )                                         # weight probability of Cell_ID selection by abundance
SortMatrix <- OGcounts[OGcounts$Cell_ID %not in% cells_lost_sort, ]                       # store selected cells in new data frame
# (3) Determine time to research ~50k cells from starting number of cells post-sort
SortMax_gr = max(SortMatrix$gr)                                                           # calculate max growth rate of selected cells
num_uniq = length(unique(SortMatrix$Cell_ID))
t_expand = solvet(g = SortMax_gr, N0 = sum(SortMatrix$counts), Nfinal = 0.85*k_96well, k = k_96well)   # solve logistic growth equation for expansion time
# (4) Simulate growth of each subclone to t_expand and store new cell counts and abundance in data frame
SortOut <- SortMatrix %>% select(-abund) %>%
mutate(counts = floor(solveN(g = gr, N0 = counts, tf = t_expand, k = k_96well)),         #
abund = counts/sum(counts))
head(SortOut)
print(paste("total number of cells after expansion = ",sum(SortOut$counts)))
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(tidyverse)
library_size = 1000        # number of barcoded cells sorted/intended library size [number of cells]
mean_growth_rate = 0.022   # mean growth rate of cell line to be used [1/hr]
cell_doubl_time = NA       # estimated cell doubling time [hr]
sd_growth_rate = 0.003        # standard deviation around mean growth rate [1/hr]
prob_cellsort_death = 0.15    # probability of death after cell sort [ ]
k_96well = 55e3               # carrying capacity of a 96-well plate [number of cells]
`%not in%` <- negate(`%in%`)
### LOGISTIC GROWTH ###
# function to solve a logistic growth equation for the final number of cells given growth rate, starting number of cells, carrying capacity and the final time point
solveN <- function(g, N0, tfinal, k)
{
Nfinal <- (k*N0)/(N0 + ((k-N0)*exp(-g*tfinal)) )
return(Nfinal)
}
### LOGISTIC GROWTH ###
# function to solve a logistic growth equation for the final time given growth rate, starting number of cells, carrying capacity, and the final number of cells
solvet <- function(g, N0, Nfinal, k)
{
tfinal <- -(log((N0*(1-(k/Nfinal)))/(N0-k)))/g
return(tfinal)
}
set.seed(1212)
### SORT CELLS
# (1) Setup initial cell count matrix with number of cells equal to the number of cells sorted
OGcounts <- data.frame("Cell_ID"= c(seq(1,library_size))) %>%                             # create matrix with cells equal to sorted library size
add_column(    gr = rnorm(nrow(.), mean=mean_growth_rate, sd=sd_growth_rate), # sample growth rates from normal distribution
counts = c(rep(1,library_size)) )                                  # set initial count of each subclone to 1
OGcounts <- OGcounts %>% mutate(abund= counts/sum(OGcounts$counts))                       # add new column for subclonal abundance
# (2) Stochastic selection of cells that die post-cell sort
cells_lost_sort = sample(    x = OGcounts$Cell_ID,                                        # choose from set of Cell_IDs in data frame
size = round(prob_cellsort_death*sum(OGcounts$counts)),         # select number of cells equal to current number of cells multiplied by probability of death post cell sort (prob_cellsort_death)
prob = OGcounts$abund )                                         # weight probability of Cell_ID selection by abundance
SortMatrix <- OGcounts[OGcounts$Cell_ID %not in% cells_lost_sort, ]                       # store selected cells in new data frame
# (3) Determine time to research ~50k cells from starting number of cells post-sort
SortMax_gr = max(SortMatrix$gr)                                                           # calculate max growth rate of selected cells
num_uniq = length(unique(SortMatrix$Cell_ID))
t_expand = solvet(g = SortMax_gr, N0 = sum(SortMatrix$counts), Nfinal = 0.85*k_96well, k = k_96well)   # solve logistic growth equation for expansion time
# (4) Simulate growth of each subclone to t_expand and store new cell counts and abundance in data frame
SortOut <- SortMatrix %>% select(-abund) %>%
mutate(counts = floor(solveN(g = gr, N0 = counts, tf = t_expand, k = k_96well)),         #
abund = counts/sum(counts))
head(SortOut)
print(paste("total number of cells after expansion = ",sum(SortOut$counts)))
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(tidyverse)
library_size = 1000        # number of barcoded cells sorted/intended library size [number of cells]
mean_growth_rate = 0.022   # mean growth rate of cell line to be used [1/hr]
cell_doubl_time = NA       # estimated cell doubling time [hr]
sd_growth_rate = 0.003        # standard deviation around mean growth rate [1/hr]
prob_cellsort_death = 0.15    # probability of death after cell sort [ ]
k_96well = 55e3               # carrying capacity of a 96-well plate [number of cells]
`%not in%` <- negate(`%in%`)
### LOGISTIC GROWTH ###
# function to solve a logistic growth equation for the final number of cells given growth rate, starting number of cells, carrying capacity and the final time point
solveN <- function(g, N0, tfinal, k)
{
Nfinal <- (k*N0)/(N0 + ((k-N0)*exp(-g*tfinal)) )
return(Nfinal)
}
### LOGISTIC GROWTH ###
# function to solve a logistic growth equation for the final time given growth rate, starting number of cells, carrying capacity, and the final number of cells
solvet <- function(g, N0, Nfinal, k)
{
tfinal <- -(log((N0*(1-(k/Nfinal)))/(N0-k)))/g
return(tfinal)
}
### SORT CELLS
# (1) Setup initial cell count matrix with number of cells equal to the number of cells sorted
OGcounts <- data.frame("Cell_ID"= c(seq(1,library_size))) %>%                             # create matrix with cells equal to sorted library size
add_column(    gr = rnorm(nrow(.), mean=mean_growth_rate, sd=sd_growth_rate), # sample growth rates from normal distribution
counts = c(rep(1,library_size)) )                                  # set initial count of each subclone to 1
OGcounts <- OGcounts %>% mutate(abund= counts/sum(OGcounts$counts))                       # add new column for subclonal abundance
# (2) Stochastic selection of cells that die post-cell sort
cells_lost_sort = sample(    x = OGcounts$Cell_ID,                                        # choose from set of Cell_IDs in data frame
size = round(prob_cellsort_death*sum(OGcounts$counts)),         # select number of cells equal to current number of cells multiplied by probability of death post cell sort (prob_cellsort_death)
prob = OGcounts$abund )                                         # weight probability of Cell_ID selection by abundance
SortMatrix <- OGcounts[OGcounts$Cell_ID %not in% cells_lost_sort, ]                       # store selected cells in new data frame
# (3) Determine time to research ~50k cells from starting number of cells post-sort
SortMax_gr = max(SortMatrix$gr)                                                           # calculate max growth rate of selected cells
num_uniq = length(unique(SortMatrix$Cell_ID))
t_expand = solvet(g = SortMax_gr, N0 = sum(SortMatrix$counts), Nfinal = 0.85*k_96well, k = k_96well)   # solve logistic growth equation for expansion time
### EXPAND CELLS
# (4) Simulate growth of each subclone to t_expand and store new cell counts and abundance in data frame
SortGrow <- SortMatrix %>% select(-abund) %>%
mutate(counts = floor(solveN(g = gr, N0 = counts, tf = t_expand, k = k_96well)), # solve logistic growth for N at expansion time for each Cell_ID
abund = counts/sum(counts))                                              # determine abundance of each Cell_ID in population
head(SortGrow)
print(paste("total number of cells after expansion = ",sum(SortGrow$counts)))
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(tidyverse)
library_size = 1000        # number of barcoded cells sorted/intended library size [number of cells]
mean_growth_rate = 0.022   # mean growth rate of cell line to be used [1/hr]
cell_doubl_time = NA       # estimated cell doubling time [hr]
sd_growth_rate = 0.003        # standard deviation around mean growth rate [1/hr]
prob_cellsort_death = 0.15    # probability of death after cell sort [ ]
k_96well = 55e3               # carrying capacity of a 96-well plate [number of cells]
`%not in%` <- negate(`%in%`)
### LOGISTIC GROWTH ###
# function to solve a logistic growth equation for the final number of cells given growth rate, starting number of cells, carrying capacity and the final time point
solveN <- function(g, N0, tfinal, k)
{
Nfinal <- (k*N0)/(N0 + ((k-N0)*exp(-g*tfinal)) )
return(Nfinal)
}
### LOGISTIC GROWTH ###
# function to solve a logistic growth equation for the final time given growth rate, starting number of cells, carrying capacity, and the final number of cells
solvet <- function(g, N0, Nfinal, k)
{
tfinal <- -(log((N0*(1-(k/Nfinal)))/(N0-k)))/g
return(tfinal)
}
### SORT CELLS
# (1) Setup initial cell count matrix with number of cells equal to the number of cells sorted
OGcounts <- data.frame("Cell_ID"= c(seq(1,library_size))) %>%                             # create matrix with cells equal to sorted library size
add_column(    gr = rnorm(nrow(.), mean=mean_growth_rate, sd=sd_growth_rate), # sample growth rates from normal distribution
counts = c(rep(1,library_size)) )                                  # set initial count of each subclone to 1
OGcounts <- OGcounts %>% mutate(abund= counts/sum(OGcounts$counts))                       # add new column for subclonal abundance
# (2) Stochastic selection of cells that die post-cell sort
cells_lost_sort = sample(    x = OGcounts$Cell_ID,                                        # choose from set of Cell_IDs in data frame
size = round(prob_cellsort_death*sum(OGcounts$counts)),         # select number of cells equal to current number of cells multiplied by probability of death post cell sort (prob_cellsort_death)
prob = OGcounts$abund )                                         # weight probability of Cell_ID selection by abundance
SortMatrix <- OGcounts[OGcounts$Cell_ID %not in% cells_lost_sort, ]                       # store selected cells in new data frame
# (3) Determine time to research ~50k cells from starting number of cells post-sort
SortMax_gr = max(SortMatrix$gr)                                                           # calculate max growth rate of selected cells
num_uniq = length(unique(SortMatrix$Cell_ID))
t_expand = solvet(g = SortMax_gr, N0 = sum(SortMatrix$counts), Nfinal = 0.85*k_96well, k = k_96well)   # solve logistic growth equation for expansion time
### EXPAND CELLS
# (4) Simulate growth of each subclone to t_expand and store new cell counts and abundance in data frame
SortGrow <- SortMatrix %>% select(-abund) %>%
mutate(counts = floor(solveN(g = gr, N0 = counts, tf = t_expand, k = k_96well)), # solve logistic growth for N at expansion time for each Cell_ID
abund = counts/sum(counts))                                              # determine abundance of each Cell_ID in population
head(SortGrow)
print(paste("total number of cells after expansion = ",sum(SortGrow$counts)))
prob_passage_death = 0.05     # cells lost during routine passaging [ ]
### SORT CELLS
# (1) Setup initial cell count matrix with number of cells equal to the number of cells sorted
OGcounts <- data.frame("Cell_ID"= c(seq(1,library_size))) %>%                             # create matrix with cells equal to sorted library size
add_column(    gr = rnorm(nrow(.), mean=mean_growth_rate, sd=sd_growth_rate), # sample growth rates from normal distribution
counts = c(rep(1,library_size)) )                                  # set initial count of each subclone to 1
OGcounts <- OGcounts %>% mutate(abund= counts/sum(OGcounts$counts))                       # add new column for subclonal abundance
# (2) Stochastic selection of cells that die post-cell sort
cells_lost_sort = sample(    x = OGcounts$Cell_ID,                                        # choose from set of Cell_IDs in data frame
size = round(prob_cellsort_death*sum(OGcounts$counts)),         # select number of cells equal to current number of cells multiplied by probability of death post cell sort (prob_cellsort_death)
prob = OGcounts$abund )                                         # weight probability of Cell_ID selection by abundance
SortMatrix <- OGcounts[OGcounts$Cell_ID %not in% cells_lost_sort, ]                       # store selected cells in new data frame
# (3) Determine time to research ~50k cells from starting number of cells post-sort
SortMax_gr = max(SortMatrix$gr)                                                           # calculate max growth rate of selected cells
num_uniq = length(unique(SortMatrix$Cell_ID))
t_expand = solvet(g = SortMax_gr, N0 = sum(SortMatrix$counts), Nfinal = 0.85*k_96well, k = k_96well)   # solve logistic growth equation for expansion time
### EXPAND CELLS
# (4) Simulate growth of each subclone to t_expand and store new cell counts and abundance in data frame
SortGrow <- SortMatrix %>% select(-abund) %>%
mutate(counts = floor(solveN(g = gr, N0 = counts, tf = t_expand, k = k_96well)), # solve logistic growth for N at expansion time for each Cell_ID
abund = counts/sum(counts))                                              # determine abundance of each Cell_ID in population
head(SortGrow)
print(paste("total number of cells after expansion = ",sum(SortGrow$counts)))
# (5) Stochastic selection of cells that die during expansion to new vessel
cells_lost_expand = sample(    x = SortGrow$Cell_ID,                                        # choose from set of Cell_IDs in data frame
size = round(prob_passage_death*sum(SortGrow$counts)),         # select number of cells equal to current number of cells multiplied by probability of death post cell sort (prob_cellsort_death)
prob = SortGrow$abund )                                         # weight probability of Cell_ID selection by abundance
# (5) Stochastic selection of cells that die during expansion to new vessel
cells_lost_expand = sample(    x = SortGrow$Cell_ID,                                     # choose from set of Cell_IDs in data frame
size = round(prob_passage_death*sum(SortGrow$counts)),         # select number of cells equal to current number of cells multiplied by probability of death post cell sort (prob_cellsort_death)
prob = SortGrow$abund,                                         # weight probability of Cell_ID selection by abundance
replace = TRUE)
SortOut <- SortGrow[SortGrow$Cell_ID %not in% cells_lost_expand, ]                       # store selected cells in new data frame
SortOut
### SORT CELLS
# (1) Setup initial cell count matrix with number of cells equal to the number of cells sorted
OGcounts <- data.frame("Cell_ID"= c(seq(1,library_size))) %>%                             # create matrix with cells equal to sorted library size
add_column(    gr = rnorm(nrow(.), mean=mean_growth_rate, sd=sd_growth_rate), # sample growth rates from normal distribution
counts = c(rep(1,library_size)) )                                  # set initial count of each subclone to 1
OGcounts <- OGcounts %>% mutate(abund= counts/sum(OGcounts$counts))                       # add new column for subclonal abundance
# (2) Stochastic selection of cells that die post-cell sort
cells_lost_sort = sample(    x = OGcounts$Cell_ID,                                        # choose from set of Cell_IDs in data frame
size = round(prob_cellsort_death*sum(OGcounts$counts)),         # select number of cells equal to current number of cells multiplied by probability of death post cell sort (prob_cellsort_death)
prob = OGcounts$abund )                                         # weight probability of Cell_ID selection by abundance
SortMatrix <- OGcounts[OGcounts$Cell_ID %not in% cells_lost_sort, ]                       # store selected cells in new data frame
# (3) Determine time to research ~50k cells from starting number of cells post-sort
SortMax_gr = max(SortMatrix$gr)                                                           # calculate max growth rate of selected cells
num_uniq = length(unique(SortMatrix$Cell_ID))
t_expand = solvet(g = SortMax_gr, N0 = sum(SortMatrix$counts), Nfinal = 0.85*k_96well, k = k_96well)   # solve logistic growth equation for expansion time
### EXPAND CELLS
# (4) Simulate growth of each subclone to t_expand and store new cell counts and abundance in data frame
SortGrow <- SortMatrix %>% select(-abund) %>%
mutate(counts = floor(solveN(g = gr, N0 = counts, tf = t_expand, k = k_96well)), # solve logistic growth for N at expansion time for each Cell_ID
abund = counts/sum(counts))                                              # determine abundance of each Cell_ID in population
head(SortGrow)
print(paste("total number of cells after expansion = ",sum(SortGrow$counts)))
# (5) Stochastic selection of cells that die during expansion to new vessel
cells_lost_expand = sample(    x = SortGrow$Cell_ID,                                     # choose from set of Cell_IDs in data frame
size = round(prob_passage_death*sum(SortGrow$counts)),         # select number of cells equal to current number of cells multiplied by probability of death post cell sort (prob_cellsort_death)
prob = SortGrow$abund,                                         # weight probability of Cell_ID selection by abundance
replace = TRUE)
SortOut <- SortGrow[SortGrow$Cell_ID %not in% cells_lost_expand, ]                       # store selected cells in new data frame
print(paste("total number of cells after replating = ",sum(SortOut$counts)))
SortGrow
print(paste("total number of cells after expansion = ",sum(SortGrow$counts)))
cells_lost_expand
# count occurences of each cell_ID in cells_lost_expand
table(cells_lost_expand)
# count occurences of each cell_ID in cells_lost_expand
data.frame(table(cells_lost_expand))
# count occurences of each cell_ID in cells_lost_expand
data.frame(table(cells_lost_expand), colnames(c('Cell_ID', 'num_cells_lost')))
# count occurences of each cell_ID in cells_lost_expand
data.frame(table(cells_lost_expand)))
# count occurences of each cell_ID in cells_lost_expand
data.frame(table(cells_lost_expand))
# count occurences of each cell_ID in cells_lost_expand
data.frame(table(cells_lost_expand), colnames(c('Cell_ID', 'num_cells_lost'))
# count occurences of each cell_ID in cells_lost_expand
data.frame(table(cells_lost_expand), colnames(c('Cell_ID', 'num_cells_lost'))
# count occurences of each cell_ID in cells_lost_expand
data.frame(table(cells_lost_expand))
num_lost <- data.frame(table(cells_lost_expand))
colnames(num_lost) <- c('Cell_ID', 'num_cells_lost')
num_lost <- data.frame(table(cells_lost_expand))
colnames(num_lost) <- c('Cell_ID', 'num_cells_lost')
num_lost
num_lost$Cell_ID <- as.character(num_lost$Cell_ID)
num_lost
SortGrow
num_lost$Cell_ID <- as.interger(as.character(num_lost$Cell_ID)) # change data type of cell_id column to integer
num_lost$Cell_ID <- as.integer(as.character(num_lost$Cell_ID)) # change data type of cell_id column to integer
num_lost
SortGrow
left_join(SortGrow, num_lost)
left_join(SortGrow, num_lost, NA=0)
left_join(SortGrow, num_lost)
left_join(SortGrow, num_lost) %>% mutate(new_count = counts - num_cells_lost)
(left_join(SortGrow, num_lost) %>% mutate(new_count = counts - num_cells_lost))$new_count
left_join(SortGrow, num_lost) %>% mutate(new_count = counts - num_cells_lost))
left_join(SortGrow, num_lost) %>% mutate(new_count = counts - num_cells_lost)
update_counts <- left_join(SortGrow, num_lost)
update_counts
update_counts$num_cells_lost[is.na(update_counts$num_cells_lost)]
update_counts$num_cells_lost[is.na(update_counts$num_cells_lost)] <- 0
update_counts
update_counts
update_counts %>% mutate(new_count = counts - num_cells_lost)
update_counts <- update_counts %>% mutate(new_count = counts - num_cells_lost)
update_counts
update_counts <- update_counts %>% mutate(counts = counts - num_cells_lost)
update_counts
update_counts <- left_join(SortGrow, num_lost)
update_counts$num_cells_lost[is.na(update_counts$num_cells_lost)] <- 0
update_counts <- update_counts %>% mutate(counts = counts - num_cells_lost)
update_counts
update_counts <- update_counts %>% select(-abund) %>% mutate(counts = counts - num_cells_lost)
update_counts
update_counts <- update_counts %>% select(-abund) %>% mutate(counts = counts - num_cells_lost) %>% mutate(abund= counts/colSums(counts)))
update_counts <- update_counts %>% select(-abund) %>% mutate(counts = counts - num_cells_lost) %>% mutate(abund= counts/colSums(counts))
update_counts <- update_counts %>% select(-abund) %>% mutate(counts = counts - num_cells_lost) %>% mutate(abund= counts/colSums(counts) )
update_counts <- update_counts %>% select(-abund) %>% mutate(counts = counts - num_cells_lost) %>% mutate(abund = counts/colSums(counts) )
update_counts <- left_join(SortGrow, num_lost)
update_counts$num_cells_lost[is.na(update_counts$num_cells_lost)] <- 0
update_counts <- update_counts %>% select(-abund) %>% mutate(counts = counts - num_cells_lost) %>% mutate(abund = counts/colSums(counts) )
update_counts <- left_join(SortGrow, num_lost)
update_counts$num_cells_lost[is.na(update_counts$num_cells_lost)] <- 0
update_counts %>% select(-abund)
update_counts %>% select(-abund) %>% mutate(counts = counts - num_cells_lost)
update_counts %>% select(-abund) %>% mutate(counts = counts - num_cells_lost) %>% mutate(abund = counts/colSums(counts) )
update_counts %>% select(-abund) %>% mutate(counts = counts - num_cells_lost) %>% mutate(abund = counts/sum(counts) )
sum(counts)
update_counts %>% select(-abund) %>% mutate(counts = counts - num_cells_lost) %>% mutate(sum_counts = sum(counts), abund = counts/sum(counts) )
update_counts %>% select(-abund) %>% mutate(counts = counts - num_cells_lost) %>% mutate(abund = counts/sum(counts) )
update_counts <- update_counts %>% select(-abund) %>% mutate(counts = counts - num_cells_lost) %>% mutate(abund = counts/sum(counts) )
update_counts
update_counts <- update_counts %>% select(-abund) %>% mutate(counts = counts - num_cells_lost) %>% mutate(abund = counts/sum(counts) ) %>% select(-num_cells_lost)
print(paste("total number of cells after replating = ",sum(SortOut$counts)))
### SORT CELLS
# (1) Setup initial cell count matrix with number of cells equal to the number of cells sorted
OGcounts <- data.frame("Cell_ID"= c(seq(1,library_size))) %>%                             # create matrix with cells equal to sorted library size
add_column(    gr = rnorm(nrow(.), mean=mean_growth_rate, sd=sd_growth_rate), # sample growth rates from normal distribution
counts = c(rep(1,library_size)) )                                  # set initial count of each subclone to 1
OGcounts <- OGcounts %>% mutate(abund= counts/sum(OGcounts$counts))                       # add new column for subclonal abundance
# (2) Stochastic selection of cells that die post-cell sort
cells_lost_sort = sample(    x = OGcounts$Cell_ID,                                        # choose from set of Cell_IDs in data frame
size = round(prob_cellsort_death*sum(OGcounts$counts)),         # select number of cells equal to current number of cells multiplied by probability of death post cell sort (prob_cellsort_death)
prob = OGcounts$abund )                                         # weight probability of Cell_ID selection by abundance
SortMatrix <- OGcounts[OGcounts$Cell_ID %not in% cells_lost_sort, ]                       # store selected cells in new data frame
# (3) Determine time to research ~50k cells from starting number of cells post-sort
SortMax_gr = max(SortMatrix$gr)                                                           # calculate max growth rate of selected cells
num_uniq = length(unique(SortMatrix$Cell_ID))
t_expand = solvet(g = SortMax_gr, N0 = sum(SortMatrix$counts), Nfinal = 0.85*k_96well, k = k_96well)   # solve logistic growth equation for expansion time
### EXPAND CELLS
# (4) Simulate growth of each subclone to t_expand and store new cell counts and abundance in data frame
SortGrow <- SortMatrix %>% select(-abund) %>%
mutate(counts = floor(solveN(g = gr, N0 = counts, tf = t_expand, k = k_96well)), # solve logistic growth for N at expansion time for each Cell_ID
abund = counts/sum(counts))                                              # determine abundance of each Cell_ID in population
head(SortGrow)
print(paste("total number of cells after expansion = ",sum(SortGrow$counts)))
# (5) Stochastic selection of cells that die during expansion to new vessel
cells_lost_expand = sample(    x = SortGrow$Cell_ID,                                     # choose from set of Cell_IDs in data frame
size = round(prob_passage_death*sum(SortGrow$counts)),         # select number of cells equal to current number of cells multiplied by probability of death post cell sort (prob_cellsort_death)
prob = SortGrow$abund,                                         # weight probability of Cell_ID selection by abundance
replace = TRUE)
#SortOut <- SortGrow[SortGrow$Cell_ID %not in% cells_lost_expand, ]                       # store selected cells in new data frame
# count occurences of each cell_ID in cells_lost_expand
num_lost <- data.frame(table(cells_lost_expand))                 # count occurrences of each cell id
colnames(num_lost) <- c('Cell_ID', 'num_cells_lost')             # rename columns
num_lost$Cell_ID <- as.integer(as.character(num_lost$Cell_ID)) # change data type of cell_id column to intege
update_counts <- left_join(SortGrow, num_lost)
update_counts$num_cells_lost[is.na(update_counts$num_cells_lost)] <- 0
update_counts <- update_counts %>% select(-abund) %>% mutate(counts = counts - num_cells_lost) %>% mutate(abund = counts/sum(counts) ) %>% select(-num_cells_lost)
print(paste("total number of cells after replating = ",sum(SortOut$counts)))
SortOut <- update_counts %>% select(-abund) %>% mutate(counts = counts - num_cells_lost) %>% mutate(abund = counts/sum(counts) ) %>% select(-num_cells_lost)
### SORT CELLS
# (1) Setup initial cell count matrix with number of cells equal to the number of cells sorted
OGcounts <- data.frame("Cell_ID"= c(seq(1,library_size))) %>%                             # create matrix with cells equal to sorted library size
add_column(    gr = rnorm(nrow(.), mean=mean_growth_rate, sd=sd_growth_rate), # sample growth rates from normal distribution
counts = c(rep(1,library_size)) )                                  # set initial count of each subclone to 1
OGcounts <- OGcounts %>% mutate(abund= counts/sum(OGcounts$counts))                       # add new column for subclonal abundance
# (2) Stochastic selection of cells that die post-cell sort
cells_lost_sort = sample(    x = OGcounts$Cell_ID,                                        # choose from set of Cell_IDs in data frame
size = round(prob_cellsort_death*sum(OGcounts$counts)),         # select number of cells equal to current number of cells multiplied by probability of death post cell sort (prob_cellsort_death)
prob = OGcounts$abund )                                         # weight probability of Cell_ID selection by abundance
SortMatrix <- OGcounts[OGcounts$Cell_ID %not in% cells_lost_sort, ]                       # store selected cells in new data frame
# (3) Determine time to research ~50k cells from starting number of cells post-sort
SortMax_gr = max(SortMatrix$gr)                                                           # calculate max growth rate of selected cells
num_uniq = length(unique(SortMatrix$Cell_ID))
t_expand = solvet(g = SortMax_gr, N0 = sum(SortMatrix$counts), Nfinal = 0.85*k_96well, k = k_96well)   # solve logistic growth equation for expansion time
### EXPAND CELLS
# (4) Simulate growth of each subclone to t_expand and store new cell counts and abundance in data frame
SortGrow <- SortMatrix %>% select(-abund) %>%
mutate(counts = floor(solveN(g = gr, N0 = counts, tf = t_expand, k = k_96well)), # solve logistic growth for N at expansion time for each Cell_ID
abund = counts/sum(counts))                                              # determine abundance of each Cell_ID in population
head(SortGrow)
print(paste("total number of cells after expansion = ",sum(SortGrow$counts)))
# (5) Stochastic selection of cells that die during expansion to new vessel
cells_lost_expand = sample(    x = SortGrow$Cell_ID,                                     # choose from set of Cell_IDs in data frame
size = round(prob_passage_death*sum(SortGrow$counts)),         # select number of cells equal to current number of cells multiplied by probability of death post cell sort (prob_cellsort_death)
prob = SortGrow$abund,                                         # weight probability of Cell_ID selection by abundance
replace = TRUE)
#SortOut <- SortGrow[SortGrow$Cell_ID %not in% cells_lost_expand, ]                       # store selected cells in new data frame
# count occurences of each cell_ID in cells_lost_expand
num_lost <- data.frame(table(cells_lost_expand))                 # count occurrences of each cell id
colnames(num_lost) <- c('Cell_ID', 'num_cells_lost')             # rename columns
num_lost$Cell_ID <- as.integer(as.character(num_lost$Cell_ID)) # change data type of cell_id column to intege
update_counts <- left_join(SortGrow, num_lost)
update_counts$num_cells_lost[is.na(update_counts$num_cells_lost)] <- 0
SortOut <- update_counts %>% select(-abund) %>% mutate(counts = counts - num_cells_lost) %>% mutate(abund = counts/sum(counts) ) %>% select(-num_cells_lost)
print(paste("total number of cells after replating = ",sum(SortOut$counts)))
SortOut <- update_counts %>% select(-abund) %>% mutate(counts = counts - num_cells_lost) %>%
mutate(abund = counts/sum(counts) ) %>%
select(-num_cells_lost)
