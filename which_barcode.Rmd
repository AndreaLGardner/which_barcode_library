---
title: "Barcode Diversity"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(tidyverse)
```

############ USER INPUTS ####################################
```{r}
library_size = 1000        # number of barcoded cells sorted/intended library size [number of cells]
mean_growth_rate = 0.022   # mean growth rate of cell line to be used [1/hr]
cell_doubl_time = NA       # estimated cell doubling time [hr]

```


############ SET INPUTS ####################################
```{r}
sd_growth_rate = 0.003        # standard deviation around mean growth rate [1/hr]
prob_cellsort_death = 0.15    # probability of death after cell sort [ ]
k_96well = 55e3               # carrying capacity of a 96-well plate [number of cells]
```


######## SET SIMPLE FUNCTIONS ##############################
```{r}
`%not in%` <- negate(`%in%`)

### LOGISTIC GROWTH ###
# function to solve a logistic growth equation for the final number of cells given growth rate, starting number of cells, carrying capacity and the final time point
solveN <- function(g, N0, tfinal, k)
  {
    Nfinal <- (k*N0)/(N0 + ((k-N0)*exp(-g*tfinal)) )
    return(Nfinal)
  }

### LOGISTIC GROWTH ###
# function to solve a logistic growth equation for the final time given growth rate, starting number of cells, carrying capacity, and the final number of cells
solvet <- function(g, N0, Nfinal, k)
  {
  tfinal <- -(log((N0*(1-(k/Nfinal)))/(N0-k)))/g  
  return(tfinal)
  }

```



############ SORT PHASE ####################################
```{r}

set.seed(1212)

### SORT CELLS
# (1) Setup initial cell count matrix with number of cells equal to the number of cells sorted

OGcounts <- data.frame("Cell_ID"= c(seq(1,library_size))) %>%                             # create matrix with cells equal to sorted library size
            add_column(    gr = rnorm(nrow(.), mean=mean_growth_rate, sd=sd_growth_rate), # sample growth rates from normal distribution
                       counts = c(rep(1,library_size)) )                                  # set initial count of each subclone to 1

OGcounts <- OGcounts %>% mutate(abund= counts/sum(OGcounts$counts))                       # add new column for subclonal abundance

# (2) Stochastic selection of cells that die post-cell sort
cells_lost_sort = sample(    x = OGcounts$Cell_ID,                                        # choose from set of Cell_IDs in data frame
                          size = round(prob_cellsort_death*sum(OGcounts$counts)),         # select number of cells equal to current number of cells multiplied by probability of death post cell sort (prob_cellsort_death)
                          prob = OGcounts$abund )                                         # weight probability of Cell_ID selection by abundance

SortMatrix <- OGcounts[OGcounts$Cell_ID %not in% cells_lost_sort, ]                       # store selected cells in new data frame


# (3) Determine time to research ~50k cells from starting number of cells post-sort
SortMax_gr = max(SortMatrix$gr)                                                           # calculate max growth rate of selected cells
num_uniq = length(unique(SortMatrix$Cell_ID))
t_expand = solvet(g = SortMax_gr, N0 = sum(SortMatrix$counts), Nfinal = 0.85*k_96well, k = k_96well)   # solve logistic growth equation for expansion time


# (4) Simulate growth of each subclone to t_expand and store new cell counts and abundance in data frame
SortOut <- SortMatrix %>% select(-abund) %>% 
           mutate(counts = floor(solveN(g = gr, N0 = counts, tf = t_expand, k = k_96well)), # solve logistic growth for N at expansion time for each Cell_ID        
                   abund = counts/sum(counts))                                            # determine abundance of each Cell_ID in population

head(SortOut)
print(paste("total number of cells after expansion = ",sum(SortOut$counts)))

```

