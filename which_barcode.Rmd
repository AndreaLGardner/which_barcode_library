---
title: "Barcode Diversity"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(tidyverse)
```

############ USER INPUTS ####################################
```{r}
library_size = 1000        # number of barcoded cells sorted/intended library size [number of cells]
mean_growth_rate = 0.022   # mean growth rate of cell line to be used [1/hr]
cell_doubl_time = NA       # estimated cell doubling time [hr]
final_cell_count = 10e6    # number of cells needed for experiments and freezebacks
num_passages = 3           # number of expansions

```


############ SET INPUTS ####################################
```{r}
sd_growth_rate = 0.003        # standard deviation around mean growth rate [1/hr]
k_96well = 55e3               # carrying capacity of a 96-well plate [number of cells]
prob_cellsort_death = 0.15    # probability of death after cell sort [ ]
prob_passage_death = 0.05     # cells lost during routine passaging [ ]
```


######## SET SIMPLE FUNCTIONS ##############################
```{r}
`%not in%` <- negate(`%in%`)

### LOGISTIC GROWTH, NUMBER ###
# function to solve a logistic growth equation for the final number of cells given growth rate, starting number of cells, carrying capacity and the final time point
solveN <- function(g, N0, tfinal, k)
  {
    Nfinal <- (k*N0)/(N0 + ((k-N0)*exp(-g*tfinal)) )
    return(Nfinal)
  }

### LOGISTIC GROWTH, TIME ###
# function to solve a logistic growth equation for the final time given growth rate, starting number of cells, carrying capacity, and the final number of cells
solvet <- function(g, N0, Nfinal, k)
  {
    tfinal <- -(log((N0*(1-(k/Nfinal)))/(N0-k)))/g  
    return(tfinal)
  }


### LOGISITC GROWTH PER ROW IN DATA FRAME ###########
# Determine time to reach number of cells equivalent to 80% vessel capacity from known starting number of cells (t_expand)
# Then simulate growth of each subclone to t_expand and store new cell counts and abundance in data frame, return new data frame

grow_cells <- function(df, K)
  {
      max_gr = max(df$gr)                                                           # calculate max growth rate of selected cells
    t_expand = solvet(g = max_gr, N0 = sum(df$counts), Nfinal = 0.80*K, k = K)      # solve logistic growth equation for expansion time  
      df_out <- df %>% select(-abund) %>%  
              mutate(counts = floor(solveN(g = gr, N0 = counts, tf = t_expand, k = K)),   # solve logistic growth for N at expansion time for each Cell_ID        
                     abund = counts/sum(counts))                                          # determine abundance of each Cell_ID in population
    return(df_out)
  }


### STOCHASTIC SELECTION AT PASSAGE/EXPANSION ######
passage_cells <- function(df)
  {
    cells_lost_expand = sample(    x = df$Cell_ID,                                   # choose from set of Cell_IDs in data frame
                                size = round(prob_passage_death*sum(df$counts)),     # select number of cells equal to current number of cells multiplied by probability of death post cell sort (prob_cellsort_death)
                                prob = df$abund,                                     # weight probability of Cell_ID selection by abundance
                             replace = TRUE)                                         
  
    num_lost           <- data.frame(table(cells_lost_expand))                       # count occurrences of each cell id in cells_lost_expand
    colnames(num_lost) <- c('Cell_ID', 'num_cells_lost')                             # rename columns
    num_lost$Cell_ID   <- as.integer(as.character(num_lost$Cell_ID))                 # change data type of cell_id column to integer
      
    
    update_counts <- left_join(df, num_lost)                                         # join with original data frame with current cell counts
    update_counts$num_cells_lost[is.na(update_counts$num_cells_lost)] <- 0
    
    df_out <- update_counts %>% select(-abund) %>%                                   # remove old abundance data
                                mutate(counts = counts - num_cells_lost) %>%         # calculate new counts by subtracting num_cells_lost occurrences from previous count
                                mutate(abund = counts/sum(counts) ) %>%              # calculate new abundance data
                                select(-num_cells_lost)                              # remove unnecessary columns
    return(df_out)
  }

```



############ SORT PHASE ####################################
```{r}
### SORT CELLS
# (1) Setup initial cell count matrix with number of cells equal to the number of cells sorted

OGcounts <- data.frame("Cell_ID"= c(seq(1,library_size))) %>%                             # create matrix with cells equal to sorted library size
            add_column(    gr = rnorm(nrow(.), mean=mean_growth_rate, sd=sd_growth_rate), # sample growth rates from normal distribution
                       counts = c(rep(1,library_size)) )                                  # set initial count of each subclone to 1

OGcounts <- OGcounts %>% mutate(abund= counts/sum(OGcounts$counts))                       # add new column for subclonal abundance

# (2) Stochastic selection of cells that die post-cell sort
cells_lost_sort = sample(    x = OGcounts$Cell_ID,                                        # choose from set of Cell_IDs in data frame
                          size = round(prob_cellsort_death*sum(OGcounts$counts)),         # select number of cells equal to current number of cells multiplied by probability of death post cell sort (prob_cellsort_death)
                          prob = OGcounts$abund )                                         # weight probability of Cell_ID selection by abundance

SortMatrix <- OGcounts[OGcounts$Cell_ID %not in% cells_lost_sort, ]                       # store selected cells in new data frame


### EXPAND CELLS
# (3) Simulate growth of each subclone to 80% vessel carrying capacity and store new cell counts and abundance in data frame
SortGrow <- grow_cells(df = SortMatrix, K = k_96well)

SortOut <- passage_cells(df = SortGrow)

print(paste("total number of cells after expansion = ",sum(SortGrow$counts)))
print(paste("total number of cells after replating = ",sum(SortOut$counts)))
```

######### BULK EXPANSION PHASE #############################
```{r}
# take SortOut as input

# determine time (t_expand) to get to final_cell_count based on max gr in data frame

# Divide time into intervals, i.e. t_interval =  t_expand / num_passages-1

# Simulate logistic growth and stochatic cells loss similar to steps 4 and 5 above for each time step

```



##### [optional] FREEZE/THAW PHASE #########################
```{r}

```


######### EXPERIMENT PHASE #################################
```{r}

```

###### PLOTTING AND ANALYSIS #################################
```{r}

```


